\specialsection{Введение}

\specialsubsection{SMT-формулы}

\underline{SMT-формулы} (от англ. \textit{Satisfiability Modulo Theories}) являются одним из наиболее важных объектов в области практических применений математической логики. Они позволяют сначала формальным образом записать разнообразные утверждения из различных предметных областей, а затем с помощью специальных вычислительных методов проверить логическую выполнимость (состоятельность) этих утверждений.

SMT-формула является некоторым расширением SAT-формулы, которое позволяет использовать не только логические переменные и связки с ними, а ещё и выражения с участием объектов из некоторого домена (например: целые числа, вещественные числа, битовые векторы, списки) и различными операциями с ними (например: числовая арифметика, битовые операции, взятие элемента списка по индексу и т. д.).

Более формально, SMT-формула является формулой в логике первого порядка, где у каждого символа переменной или функции есть некоторый заранее определенный тип (домен), а в качестве функциональных символов используются функции и операторы из разных доменов (например, те же битовые операции или взятия элемента списка по индексу). Задача проверки выполнимости такой формулы состоит в том, чтобы выяснить, можно ли для каждой свободной (не находящейся под квантором) переменной подобрать значение соответствующего ей типа так, чтобы при подстановке данных значений формула была истинна.

Чтобы стало более понятно, покажу несколько примеров.

Пример формулы:
\begin{equation}
    (x + y + z = 2) \wedge (x + 2y + 3z = 2) \wedge (x + 2y + 4z = 1),
    \label{smt-example-1}
\end{equation}

где $x$, $y$ и $z$ --- целые числа. Эта формула является выполнимой, поскольку при подстановке значений $x \leftarrow 1$, $y \leftarrow 2$, $z \leftarrow -1$ формула превращается в истинное утверждение.

Ещё пример:
\begin{equation}
    (x = 2y) \wedge (x = 2z + 1).
    \label{smt-example-2}
\end{equation}

Если потребовать, чтобы $x$, $y$ и $z$ в этой формуле были целыми числами, то формула, очевидно, не будет выполнимой (т. к. в этом случае написанное здесь обозначает высказывание \textit{$x$ является чётным и $x$ является нечётным}). Однако, если разрешить переменным быть вещественными (или хотя бы рациональными), формула станет выполнимой. Этот пример показывает, что свойство выполнимости зависит от типовых (доменных) ограничений, наложенных на переменные и функциональные символы.

Пример формулы с кванторами:
\begin{equation}
    \exists \ x, y, z: (n \ge 0) \wedge (x > 0) \wedge (y > 0) \wedge (z > 0) \wedge (x^n + y^n = z^n),
    \label{smt-example-3}
\end{equation}

где все переменные являются целыми числами. В этой формуле присутствует только одна свободная переменная --- $n$, поэтому искать подходящее значение нужно только для неё. Нетрудно заметить, что нам подходят значения $n = 1$ и $n = 2$, поэтому формула является выполнимой (но если условие $n \ge 0$ заменить на $n \ge 3$, формула станет невыполнимой согласно Великой теореме Ферма).

Пример формулы с битовыми векторами:
\begin{equation}
    (x \ge \texttt{\#b01000000}) \wedge (x + (x \ \texttt{shl}\footnote{Здесь $\texttt{shl}$ --- \textit{shift left}: $x \ \texttt{shl} \ y$ есть битовый сдвиг вектора $x$ влево на $y$ битов.} \ \texttt{\#b00000001}) + \texttt{\#b11111111} < \texttt{\#b00100000}),
    \label{smt-example-4}
\end{equation}

где переменная $x$ является битовым вектором размера 8 (фактически, это беззнаковое числом размером 1 байт). Аналогично, все константы\footnote{Вообще константы не принято выносить как отдельную сущность в формулах, поскольку их можно считать функциями от нулевого количества аргументов и, соответственно, обозначать каждую из них своим функциональным символом из логики первого порядка. Но в этой работе для удобства я буду отделять константы, содержащиеся в формулах.} в формуле тоже являются битовыми векторами размера 8 и записываются в бинарном формате. Стоит также отметить, что каждый битовый вектор можно однозначно отождествить с числом через его запись в двоичной системе счисления (например, таким образом происходит сравнение векторов на больше-меньше).

В указанном примере демонстрируется возможность использования переменных, функций и операторов из домена битовых векторов, а также то, что их семантика может отличаться от общепринятых семантик в других доменах. Так, например, все арифметические операции с битовыми векторами (в нашем случае, это два сложения) выполняются с учётом битового переполнения. Из этого, в частности, следует, что формула из примера является выполнимой, т. к. нам подходит значение $x = \texttt{\#b01100000}$ (или 96 в десятичной системе счисления):
\begin{itemize}
    \item $x = \texttt{\#b01100000}$;
    \item $x \ge \texttt{\#b01000000}$ очевидно выполняется;
    \item $x \ \texttt{shl} \ \texttt{\#b00000001} = \texttt{\#b11000000}$;
    \item $x + (x \ \texttt{shl} \ \texttt{\#b00000001}) = \texttt{\#b01100000} + \texttt{\#b11000000} = \texttt{\#b00100000}$ из-за битового переполнения;
    \item $x + (x \ \texttt{shl} \ \texttt{\#b00000001}) + \texttt{\#b11111111} = \texttt{\#b00100000} + \texttt{\#b11111111} = \texttt{\#b00011111}$ опять же из-за переполнения;
    \item $x + (x \ \texttt{shl} \ \texttt{\#b00000001}) + \texttt{\#b11111111} = \texttt{\#b00011111} < \texttt{\#b00100000}$, что и требовалось.
\end{itemize}

% todo: пример с массивами

\specialsubsection{SMT-логики}

Говоря про домены, модальности и типы данных в SMT-формулах, важно рассказать про \underline{SMT-логики} (в русскоязычной литературе их ещё часто называют теориями). Логики задают ограничения на типы переменных, констант, функций и операторов, которые можно использовать в формуле. Согласно языку логики первого порядка, в каждой формуле вне зависимости от теории можно использовать пропозициональные переменные (ложь, истина) и константы, логические связки между ними и кванторы. Возможность использования остальных конструкций уже определяется логикой.

Так, например, логика \texttt{LIA} (\textit{Linear Integer Arithmetic}) позволяет использовать только целочисленные переменные и константы сколь угодно больших по модулю значений, а также арифметические операции и операторы сравнения (больше-меньше-равно) с их участием. Вдобавок, поскольку это линейная арифметика, все термы формулы обязаны быть линейными по каждой из переменных. Примером формулы в такой логике является формула (\ref{smt-example-1}).

Ещё один пример логики --- \texttt{LRA} (\textit{Linear Real Arithmetic}) --- аналог \texttt{LIA}: устроена так же, но позволяет использовать только вещественные переменные и константы (т. е. проверить, решается ли уравнение в целых числах, с помощью этой логики не получится). Здесь уместно вспомнить формулу (\ref{smt-example-2}), которая является выполнимой в логике \texttt{LRA}, но не является выполнимой в логике \texttt{LIA}.

Нелинейные арифметики тоже реализованы в виде логик: \texttt{NIA} (\textit{Non-linear Integer Arithmetic}) и \texttt{NRA} (\textit{Non-linear Real Arithmetic}) во всём похожи на свои линейные аналоги, но не требуют линейности формулы по переменным (формула (\ref{smt-example-3})).

Битовые векторы представлены в логике \texttt{BV} (\textit{Bit Vector}). Эта логика позволяет записывать формулы с битовыми векторами произвольного фиксированного размера, используя битовые (и, или, исключающее или, отрицание, битовые сдвиги и т. д.), структурные (конкатенация двух битовых векторов, вырезание произвольного подотрезка битового вектора, циклические сдвиги и т. д.) и арифметические (сумма, разность, произведение, целочисленное деление, остаток от деления и т. д.) операции с ними, а также операторы сравнения.

Как уже было отмечено, все арифметические операции с битовыми векторами выполняются с учётом битового переполнения, а сравнения на больше-меньше осуществляются через сравнения целых чисел, двоичными записями которых являются сравниваемые векторы. Кроме того, для удобства, каждая арифметическая операция и каждое сравнение есть в двух вариантах: беззнаковом и знаковом. Знаковый вариант отличается тем, что двоичная запись числа (которая порождается битовым вектором) читается не в обычной арифметической семантике, где каждый бит обозначает очередную степень двойки, а в семантике <<дополнение до двух>>, где самая старшая степень двойки учитывается с минусом (именно таким образом хранятся знаковые целые числа в памяти современных компьютеров).

\specialsubsection{SMT-решатели}

\specialsubsection{Применения}

\specialsubsection{Символьное исполнение}
